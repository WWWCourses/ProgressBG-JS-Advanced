<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Angular Data Binding</title>
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
	<!-- css & themes include -->
	<link rel="stylesheet" href="../../../lib/reveal.js/css/reveal.css">
	<link rel="stylesheet" href="../../../outfit/css/themes/projector.css" id="theme">
	<!-- Printing and PDF exports -->    <script>        var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? '../../../lib/reveal.js/css/print/pdf.css' : '../../../lib/reveal.js/css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<!-- CUSTOM -->
	<base target="_blank">
</head>
<body>
	<div class="reveal default center" data-transition-speed="default" data-background-transition="default">
		<div class="top_links">
			<a class="home_link" href="/ProgressBG-JS-Advanced/index.html#Course_Intro" target="_top"><i class="fa fa-home"></i></a>
			<span class="help_link" href="#"><i class="fa fa-question"></i></span>
			<div class="help_text">
				<div><span>N/Space</span><span>Next Slide</span></div>
				<div><span>P</span><span>Previous Slide</span></div>
				<div><span>O</span><span>Slides Overview</span></div>
				<div><span>ctrl+left click</span><span>Zoom Element</span></div>
			</div>
		</div>
		<div class="footer theme_switch">
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/dark.css'); return false;">Dark</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/light.css'); return false;">Light</a>
			<a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/projector.css'); return false;">Projector</a>
		</div>
		<div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section><h1>Angular Data Binding</h1></section>
<section data-transition="zoom">
	<div class="copyright">
		<div class="note">
			<p>Created for</p>
		</div>
		<div class="company">
			<a href="http://progressbg.net/kurs-po-web-design/">
			<img style="height:80%" src="../../../outfit/images/logos/ProgressBG_logo_529_127.png">
			</a>
		</div>
		<div class="author">
			<span>Iva E. Popova, 2018-2019,</span>
			<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
		</div>
	</div>
</section>


<section data-min="1"><h1>Overview</h1></section>
<section><h2>Overview</h2>
	<section>
		<dl class="fa" style="font-size: .8em">
			<dt><span class="note">data binding</span> == synchronization between elements of the component UI (<em>view</em>) and the data in the component class (<em>model</em>), and vice versa.</dt>
		</dl>
		<a href="images/AngularDataBinding_MY.png"><img src="images/AngularDataBinding_MY.png"></a>
	</section>
	<section>
		<dl class="fa">
			<dt>Data binding can control every aspect of the user interface:</dt>
			<dd>hiding elements, showing results, closing things, accepting user input, and more</dd>
			<dt>Data bindings are expressions embedded into templates and are evaluated to produce dynamic content in the HTML document.</dt>
			<dt>Data bindings are applied as attributes on HTML elements or as special sequences of characters in strings</dt>
			<dt>Data bindings contain simple JavaScript expressions.</dt>
		</dl>
	</section>
	<section><h3>binding flows</h3>
		<a href="images/DataBindingFlows.png"><img src="images/DataBindingFlows.png"></a>
	</section>
	<section><h3>binding flows</h3>
		<dl class="fa">
			<dt class="note">One-way <b>data binding</b>:</dt>
			<dd>data model => component class => (data binding expression) => template</dd>
			<dt class="note">One-way <b>event binding</b>:</dt>
			<dd>template => component class => data model</dd>
			<dt class="note">Two-way data binding</dt>
			<dd>data and event flows in both directions</dd>
		</dl>
	</section>
	<section>
		<a href="images/DataBindingTypes.png"><img src="images/DataBindingTypes.png"></a>
	</section>
	<section>
		<dl class="fa">
			<dt>One-way Data Binding</dt>
			<dd>Interpolation <code class="note">{{value}}</code></dd>
			<dd>Property binding <code class="note">[property]="value"</code></dd>
			<dd>Event binding <code class="note">(event)="event handler"</code></dd>
			<dt>Two-way Data Binding</dt>
			<dd><code class="note">[(ngModel)]</code></dd>
		</dl>
	</section>
	<section><h3>Notes on two-way data binding</h3>
		<dl class="fa">
			<dt>In Angular 1, the default option was two-way data binding.</dt>
			<dt>Thought, it 's easy to implement it cause a lots of problems (cascading effects, coupling of "data layout tree" and  "dom view tree", etc.)</dt>
			<dt>The recommended way in Angular 2, and in many modern web frameworks (such as React), is to adopt a pattern of <span class="note">one-way data binding</span></dt>
		</dl>
	</section>
	<section><h3>Data Binding Anatomy</h3>
		<a href="images/AngularDataBindingAnatomy.png"><img src="images/AngularDataBindingAnatomy.png"></a>
	</section>
	<section><h3>Data Binding Anatomy</h3>
		<dl class="fa" style="font-size: .8em">
			<dt><span class="note">Host Element</span> - the HTML element that the binding will affect, by changing its appearance, content, or behaviour.</dt>
			<dt><span class="note">Target</span> - specifies what the binding will do. There are two different types of target: a directive or a property binding.</dt>
			<dt><span class="note">Expression</span> - a fragment of JavaScript code that is evaluated using the template’s component to provide context, i.e. the component’s property and methods can be included in the expression</dt>
			<dt class="note">Expressions should be as simple as possible, as they can not be unit tested or easily debugged, thus are a source for potential bugs.</dt>
		</dl>
	</section>
</section>

<section data-min="10"><h1>Property Binding</h1></section>
<section><h2>Property Binding</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>Most commonly, property binding sets an element DOM property to a component property value.</dt>
			<dt>If <span class="note">binding target</span> is not a directive, then Angular checks to see whether the target can be used to create a property binding.</dt>
			<dt>There are several different types of property binding</dt>
		</dl>
	</section>
	<section><h3>HTML Attributes vs DOM Properties</h3>
		<dl class="fa">
			<dt>Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).</dt>
			<dt class="note">Attributes initialize DOM properties!</dt>
			<dt class="note">Attributes can not change! Property values can change!</dt>
			<dd>For example, the HTML attribute <code>value</code> of an input field would not change, when we type in the input. Only the DOM <code>input</code> property would change</dd>
			<dt>More on <a href="https://angular.io/guide/template-syntax#html-attribute-vs-dom-property">HTML attribute vs. DOM property</a>@angular docs.</dt>
		</dl>
	</section>
	<section><h3>Property binding types</h3>
		<table style="font-size: .8em">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td class="note">[property]</td><td>set a property on the JavaScript object that represents the host element in the DOM</td></tr>
			<tr><td class="note">[attr.html_attribute]</td><td>set the value of attributes on the host HTML element for which there are no DOM properties.</td></tr>
			<tr><td class="note">[class.calss_name]</td><td>configure class membership of the host element</td></tr>
			<tr><td class="note">[style.style_name]</td><td>configure style settings of the host element</td></tr>
		</table>
	</section>
	<section><h3>Property Binding: <code>[property]</code></h3>
		<pre><code rel="Syntax" class="typescript">
			[property]="expression"
		</code></pre>
		<pre><code rel="JS" class="js">
				<img [src]="logoPNG">
				<button [disabled]="allowAddNewItems">Add</button>
			</code></pre>
		<dl class="fa">
			<dt>Sets the <span class="note">DOM property</span> of the element to the value of the template expression.</dt>
			<dt><code>property</code> is a DOM property, not HTML attribute.</dt>
			<dt>The square brackets tells Angular to evaluate the expression and assign its value to the DOM property of the host element object.</dt>
			<dt>If the square brackets are omitted, the expression would not be evaluated, and will be assigned as a string value to the property.</dt>
		</dl>
	</section>
	<section><h3>Property Binding Methods</h3>
		<p>There are 3 ways to define a property binding in Angular:</p>
		<pre><code rel="JS" class="js">
			// method 1
			<img src="{{ logoPNG }}">
			// method 2
			<img [src]="logoPNG">
			// method 3
			<img bind-src="logoPNG">
		</code></pre>
		<dl class="fa">
			<dt>Method 1 - "Interpolation" use it to define a value, <span class="note">only if the value is a <b>string</b></span>. If it's not, you must use one of the other methods.</dt>
			<dt>Method 2 - Define property binding by wrapping brackets around an element property and binding it to a component property.</dt>
			<dt>Method 3 - Adding bind- before the element property also achieves the same thing.</dt>
		</dl>
	</section>
	<section><h3>Attribute binding</h3>
		<pre><code rel="Syntax" class="typescript" data-noescape>
			[attr.html_attribute] = "expression"
		</code></pre>
		<dl class="fa">
			<dt>You must use HTML attribute binding only in the case, where there are no equivalent property to bind to.</dt>
		</dl>
		<pre><code rel="Examples" class="html" data-escape>
			&lt;p [attr.data-index]=&quot;pIndex&quot;&gt;Paragraph&lt;/p&gt;
			&lt;p [attr.role]=&quot;tooltip&quot;&gt;Some content&lt;/p&gt;
		</code></pre>
	</section>
	<section><h3>Examples</h3>
		<pre><code rel="HTML" class="HTML">
				<input type="text" name="userName" value={{userName}}>
				<input type="text" name="userName" [value]="userName">
				<!-- note: bellow we bind to the HTML Attribute -->
				<input type="text" name="userName" [attr.value]="userName">
		</code></pre>
		<pre><code rel="TS" class="ts">
			import { Component } from '@angular/core';

			@Component({
				selector: 'app-root',
				templateUrl: './app.component.html',
				styleUrls: ['./app.component.css']
			})
			export class AppComponent {
					userName = "Ada";
			}
		</code></pre>
	</section>
	<section><h3>Property binding vs. Interpolation Common mistake</h3>
		<pre><code rel="HTML" class="HTML">
			<!-- button will be enabled: -->
			<button [disabled]="false">{{addNewItems}}</button>

			<!-- button will be enabled: -->
			<button bind-disabled="false">{{addNewItems}}</button>

			<!-- button will be disabled, as "false" is interpreted as string, not boolean: -->
			<button disabled="{{false}}">Add</button>
		</code></pre>
	</section>
</section>

<section data-min="10"><h1>Class Binding</h1></section>
<section><h2>Class Binding</h2>
	<section>
		<pre><code rel="Syntax" class="typescript" data-noescape>
			[class] = "expression"
		</code></pre>
		<dl class="fa">
			<dt>With class binding we can set or remove CSS class names from an element's class attribute.</dt>
			<dt>The result of expression will be assigned to the element's class property.</dt>
		</dl>
	</section>
	<section><h3>Class Binding - example</h3>
		<pre><code rel="Examples" class="angular">
			@Component({
				selector: 'app-data-binding-test',
				template: `
					&lt;h1 [class]=&quot;h1Style&quot;&gt;Heading styled with {{h1Style}} class.&lt;/h1&gt;
				`,
				styles: [`
					.notaBene{
						background: #CA1313;
						color: #ECDBDB;
					}
				`]
			})
			export class DataBindingTestComponent implements OnInit {
				h1Style = 'notaBene';
			}
		</code></pre>
	</section>
	<section><h3>Apply class conditionally</h3>
		<pre><code rel="Syntax" class="typescript" data-noescape>
			[class.class_name] = "expression (boolean value)"
		</code></pre>
		<dl class="fa">
			<dt>If expression is evaluated to True, the class_name will be added as value to the element's class property. If it is False - the class_name will be removed.</dt>
		</dl>
	</section>
	<section><h3>Apply class conditionally - example</h3>
		<pre><code rel="Example" class="html">
			template: `
					<p [class.italic]="true">Paragraph</p>
				`,
				styles: [`
					.italic{
						font-style: italic;
					}
				`]
		</code></pre>
	</section>
	<section><h3>ngClass Directive</h3>
		<pre><code rel="Syntax" class="typescript" data-noescape>
			[ngClass]="{'class1': true, 'class2': true}"
		</code></pre>
		<dl class="fa">
			<dt>You can bind to the ngClass to add or remove several classes simultaneously.</dt>
			<dt>ngClass should be binded to a key:value object.</dt>
			<dt>Each key of the object is a CSS class name:</dt>
			<dd>if its value is true - the class will be added</dd>
			<dd>if it is false - the class will be removed.</dd>
		</dl>
	</section>
	<section><h3>ngClass Directive - example</h3>
		<pre><code rel="HTML" class="html">
			@Component({
				selector: 'app-data-binding-test',
				template: `
					&lt;p [ngClass]=&quot;multiClass&quot;&gt;Paragraph multiClass&lt;/p&gt;
				`,
				styles: [`
					.notaBene{
						background: #CA1313;
						color: #ECDBDB;
					}
					.italic{
						font-style: italic;
					}
				`]
			})
			export class DataBindingTestComponent implements OnInit {
				multiClass = {
					'notaBene': true,
					'italic': true
				}
			}
		</code></pre>
	</section>
</section>

<section data-min="10"><h1>Styles Binding</h1></section>
<section><h2>Styles Binding</h2>
	<section>
		<pre><code rel="Syntax" class="typescript">
			[style.CSSproperty] = "expression"
		</code></pre>
		<dl class="fa">
			<dt>With style binding we set inline style.</dt>
			<dt>CSSproperty can be written as in CSS, i.e. with dash-case, or with camel-case.</dt>
			<dt>expression should return a valid CSS value for that property</dt>
		</dl>
		<pre><code rel="example" class="html">
			<p [style.background]="'#00E2FF'">A paragraph with light blue background </p>
		</code></pre>
	</section>
	<section><h3>unit extension</h3>
		<dl class="fa">
			<dt>Properties which values requires CSS units (px, %, em, ...) can be set with unit extension:</dt>
		</dl>
		<pre><code rel="Syntax" class="html">
			[style.property.unit]="expression"
		</code></pre>
		<pre><code rel="example" class="html">
			<p [style.font-size.em]="vip?3:1">A VIP paragraph</p>
		</code></pre>
	</section>
	<section><h3>NgStyle</h3>
		<pre><code rel="Syntax" class="html">
			 [ngStyle]="{'property1': 'value1', 'property2': 'value2'}
		</code></pre>
		<dl class="fa">
			<dt>With NgStyle we can set many inline styles simultaneously.</dt>
			<dt>We set ngStyle to a key:value object.</dt>
			<dd>Each key of the object is a CSS property name.</dd>
			<dd>its value is the CSS value we want to set to that property</dd>
		</dl>
	</section>
	<section><h3>NgStyle - example</h3>
		<pre><code rel="data-binding-test.component.ts" class="typescript">
			import { Component, OnInit } from '@angular/core';

			@Component({
				selector: 'app-data-binding-test',
				template: `
					<p [ngStyle]="vipStyle">Style binding with vipStyle</p>
				`,
				styles: [``]
			})
			export class DataBindingTestComponent {
				vipStyle = {
					'background': 'red',
					'font-size': '2em',
					'font-weiht': 'bold',
					'color': 'white'
				};
			}

		</code></pre>
	</section>
</section>

<section data-min="30"><h1>Events Binding</h1></section>
<section><h2>Events Binding</h2>
	<section><h3>Overview</h3>
		<dl class="fa">
			<dt>The binding directives discussed so far (property/class/style) flow data in one direction: <span class="note">from a component to an element</span>.</dt>
			<dt>When user interacts with our page, we need <span class="note">to get data</span>, i.e. the flow to  be <span class="note">from an element to a component.</span> - we can do that by <b>event binging</b>.</dt>
		</dl>
	</section>
	<section><h3>Syntax</h3>
		<pre><code rel="Syntax" class="html">
			(event_name) = "template statement"
		</code></pre>
		<pre><code rel="Example" class="html">
			<button (click)="greet()">Click me</button>
		</code></pre>
		<dl class="fa" style="font-size: .8em;">
			<dt>event_name - identifies the target event.</dt>
			<dd>Could be written with the <code>on-</code> prefix, without the brackets: <code style="font-size: .8em;">&lt;button on-click=&quot;greet()&quot;&gt;Click me&lt;/button&gt;</code></dd>
			<dt>When the event is raised, the Angular executes the <b>template statement</b>. And sets information about the event in a event object named <code>$event</code>.</dt>
		</dl>
	</section>
	<section><h3>the <code>$event</code> object</h3>
		<dl class="fa">
			<dt>The information in the event object is determined by the target event.</dt>
			<dt>If the target event is a native DOM event, then $event is a DOM event object, with properties such as target and target.value.</dt>
			<dt>If the event belongs to a directive (recall that components are directives), $event has whatever shape the directive decides to produce.</dt>
		</dl>
	</section>
</section>
<section><h3>the <code>$event</code> object - example</h3>
	<pre><code rel="HTML" class="typescript">
		import { Component, OnInit } from '@angular/core';

		@Component({
			selector: 'app-event-binding',
			template: `
				<button (click)="clickHandler($event)">Button 1</button>
				<button (click)="clickHandler($event)">Button 2</button>
			`,
			styleUrls: ['./event-binding.component.css']
		})
		export class EventBindingComponent {
			outputDisplay = 'none';

			clickHandler(e) {
				// do something with event target object:
				console.log(`${e.target.innerText} was clicked!`);
			}
		}
	</code></pre>
		<p>On each button click we will see in console: "Button 1 was clicked!" or "Button 2 was clicked!"</p>
</section>
<section><h3>template reference variable instead of $event</h3>
	<dl class="fa">
		<dt>by sending the entire $event object to the component, we can break the <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a> between the template and the component.</dt>
		<dt>That's why, when we just need to pass some data to the component, it's better to use the <a href="https://progressbg-www-courses.github.io/BKA-Angular/pages/themes/ComponentsBasics/ComponentsBasics.html#/12/2">template reference variable</a></dt>
	</dl>
</section>
<section><h3>Sending data with template reference variable - example</h3>
	<pre><code rel="event-binding.component.ts" class="typescript">
		import { Component, OnInit } from '@angular/core';

		@Component({
			selector: 'app-event-binding',
			template: `
				<input type="text" (keyup)="onKeyUp(userInput.value)" #userInput><hr>
				<div class="output">{{content}}</div>
			`,
			styles: [``]
		})
		export class EventBindingComponent {
			content = '';

			onKeyUp(inputValue) {
				this.content = inputValue;
			}
		}
	</code></pre>
</section>

<section data-min="30"><h1>Two-way Data Binding</h1></section>
<section><h2>Two-way Data Binding</h2>
	<section><h3>Overview</h3>
		<dl class="fa" style="font-size: .8em;">
			<dt>Two-way binding allows to both display a data property and update that property when the user makes changes.</dt>
			<dt>In Angular (>=2.x) we can achieve that by combination of data and event bindings.</dt>
			<dt>But Angular offers a special <span class="note">two-way data binding syntax</span> for this purpose - the "<b>banana-in-a-box</b>" syntax:</dt>
			<pre><code rel="Syntax" class="typescript" style="font-size: 1.4em">
				[(data)]
			</code></pre>
			<dt>The "<b>banana-in-a-box</b>" syntax is just a syntactic sugar for a property binding and an event binding.</dt>
		</dl>
	</section>
	<section><h3>Example</h3>
			<pre><code rel="HTML" class="js">
				<input [(ngModel)]="item.content">
				<li>{{item.content}}</li>
			</code></pre>
			<p>is equivalent to </p>
			<pre><code rel="JS" class="js">
				<input [value]="item.content" (input)="onInput($event)">
				<li>{{item.content}}</li>
			</code></pre>
		</section>
	<section><h3>Two-way binding with[(ngModel)]</h3>
		<dl class="fa">
			<dt>Using the <code>[(x)]</code> syntax is convenient for custom components, where we implement the settable property called x and a corresponding event named xChange.</dt>
			<dt>But HTML input elements do not have such properties, corresponding to Change events.</dt>
			<dt>For such cases, it is better to use the ngModel directive</dt>
			<dt class="note">FormsModule is required to use [(ngModel)]</dt>
		</dl>
	</section>
	<section><h3>Two-way binding with[(ngModel)] -example</h3>
		<dl class="fa">
			<dt>Make sure you import the FormsModule in app.module.ts:</dt>
			<pre><code rel="app.module.ts " class="typescript">
				/* Other imports */
				import { FormsModule } from '@angular/forms';

				@NgModule({
					imports: [
						BrowserModule,
						FormsModule
					],
					/* Other module metadata */
				})
				export class AppModule { }
			</code></pre>
		</dl>
	</section>
	<section><h3>Two-way binding with [(ngModel)] -example</h3>
		<pre><code rel="event-binding.component.ts" class="typescript">
			import { Component, OnInit } from '@angular/core';

			@Component({
				selector: 'app-event-binding',
				template: `
					<label>userName: <input [(ngModel)]="userName"></label>
					<div class="output">You've entered: {{userName}}</div>
				`,
				styles: [``]
			})
			export class EventBindingComponent {
				userName;
			}
		</code></pre>
	</section>
	<section><h3>[(ngModel)] equivalents</h3>
		<dl class="fa" style="font-size: .8em">
			<dt>The previous example with [(ngModel)] can be written as combination of property binding and an event binding.</dt>
			<dt>Note that, the <a href="https://developer.mozilla.org/en-US/docs/Web/Events/input">input event</a> is a standard DOM Event.</dt>
		</dl>
		<pre><code rel="event-binding.component.ts" class="typescript">
			import { Component, OnInit } from '@angular/core';

			@Component({
				selector: 'app-event-binding',
				template: `
					&lt;input [value]=&quot;userName&quot; (input)=&quot;userName = $event.target.value&quot;&gt;
					&lt;div class=&quot;output&quot;&gt;You've entered: {{userName}}&lt;/div&gt;
				`,
				styles: [``]
			})
			export class EventBindingComponent {
				userName = '';
			}
		</code></pre>
	</section>
</section>



<section class="disclaimer" data-background="../../../outfit/images/for_slides/the_end_on_sand.jpg">
	 <p>These slides are based on</p>
	 <p>customised version of </p>
	 <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
	 <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
		</div>
	</div>
	<!-- Custom processing -->

	<!-- <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/typescript.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script> -->

	<script src="../../../outfit/js/slides.js"></script>

	<!-- external scripts -->
	<script src="../../../lib/reveal.js/lib/js/head.min.js"></script>
	<script src="../../../lib/reveal.js/js/reveal.js"></script>
	 <!-- init reveal -->
	<script>
		// Full list of configuration options available at:
		// https://github.com/hakimel/reveal.js#configuration
		var highlightjsTabSize = '  ';
		Reveal.initialize({
			controls: true,
			progress: true,
			slideNumber: 'c/t',
			keyboard: true,
			history: true,
			center: true,
			width: 1024,
			height: 850,
			// Bounds for smallest/largest possible scale to apply to content
			// minScale: .5,
			maxScale: 1,
			// slide transition
			transition: 'concave', // none/fade/slide/convex/concave/zoom
			// Factor of the display size that should remain empty around the content
			margin: 0.1,
			// shift+maous click to zoom in/out element
			zoomKey: 'ctrl',
			// theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
			// transition: Reveal.getQueryHash().transition || 'default'
			// Optional reveal.js plugins
			dependencies: [
				{ src: '../../../lib/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				// { src: '../../../lib/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				// { src: '../../../lib/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: '../../../lib/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.configure({tabReplace: highlightjsTabSize}); hljs.initHighlightingOnLoad(); } },
				{ src: '../../../lib/reveal.js/plugin/zoom-js/zoom.js', async: true },
				{ src: '../../../lib/reveal.js/plugin/notes/notes.js', async: true }
			]
		});
	</script>
</body>
</html>
